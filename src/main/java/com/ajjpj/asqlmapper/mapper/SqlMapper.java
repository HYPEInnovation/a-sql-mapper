package com.ajjpj.asqlmapper.mapper;

import com.ajjpj.acollections.AList;
import com.ajjpj.acollections.ASet;
import com.ajjpj.acollections.immutable.AHashSet;
import com.ajjpj.acollections.immutable.AVector;
import com.ajjpj.acollections.util.AOption;
import com.ajjpj.asqlmapper.SqlEngine;
import com.ajjpj.asqlmapper.core.RowExtractor;
import com.ajjpj.asqlmapper.core.SqlBuilder;
import com.ajjpj.asqlmapper.core.SqlSnippet;
import com.ajjpj.asqlmapper.core.provided.ProvidedProperties;
import com.ajjpj.asqlmapper.javabeans.BeanProperty;
import com.ajjpj.asqlmapper.mapper.beans.BeanMapping;
import com.ajjpj.asqlmapper.mapper.beans.BeanMappingRegistry;

import java.sql.Connection;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.stream.Collector;
import java.util.stream.Collectors;

import static com.ajjpj.acollections.util.AUnchecker.executeUnchecked;
import static com.ajjpj.asqlmapper.core.SqlSnippet.*;


public class SqlMapper {
    private final SqlEngine sqlEngine;
    private final BeanMappingRegistry mappingRegistry;

    public SqlMapper (SqlEngine sqlEngine, BeanMappingRegistry mappingRegistry) {
        this.sqlEngine = sqlEngine.withRowExtractor(mappingRegistry.metaDataRegistry().asRowExtractor());
        this.mappingRegistry = mappingRegistry;
    }

    public SqlEngine engine() {
        return sqlEngine;
    }

    public SqlSnippet tableName(Class<?> beanType) {
        return tableName(engine().defaultConnection(), beanType);
    }
    public SqlSnippet tableName(Connection conn, Class<?> beanType) {
        return sql(mappingRegistry.getBeanMapping(conn, beanType).tableName());
    }

    public <K,T> ToManyQuery<K, ASet<T>> queryForToManyASet(Class<T> beanType, String fkName, Class<K> fkType, SqlSnippet sql) {
        return queryForToMany(beanType, fkName, fkType, sql, AHashSet.streamCollector());
    }
    public <K,T> ToManyQuery<K, AList<T>> queryForToManyAList(Class<T> beanType, String fkName, Class<K> fkType, SqlSnippet sql) {
        return queryForToMany(beanType, fkName, fkType, sql, AVector.streamCollector());
    }
    public <K,T> ToManyQuery<K, Set<T>> queryForToManySet(Class<T> beanType, String fkName, Class<K> fkType, SqlSnippet sql) {
        return queryForToMany(beanType, fkName, fkType, sql, Collectors.toSet());
    }
    public <K,T> ToManyQuery<K, List<T>> queryForToManyList(Class<T> beanType, String fkName, Class<K> fkType, SqlSnippet sql) {
        return queryForToMany(beanType, fkName, fkType, sql, Collectors.toList());
    }
    public <K,T,R> ToManyQuery<K, R> queryForToMany(Class<T> beanType, String fkName, Class<K> fkType, SqlSnippet sql, Collector<T,?,? extends R> collectorPerPk) {
        final RowExtractor rowExtractor = engine().rowExtractorFor(beanType);
        return new ToManyQueryImpl<>(rowExtractor, ProvidedProperties.empty(), fkType, fkName, beanType, sql, engine().primitiveTypeRegistry(), collectorPerPk,
                engine().defaultConnectionSupplier());
    }

    public <T> AList<T> insertMany(List<T> os) {
        return insertMany(engine().defaultConnection(), os);
    }
    private <T> AList<T> insertMany(Connection conn, List<T> os) {
        if(os.isEmpty()) return AList.empty();

        final BeanMapping beanMapping = mappingRegistry.getBeanMapping(conn, os.get(0).getClass());
        if (beanMapping.pkStrategy().isAutoIncrement()) {
            return insertManyAutoGenerated(conn, beanMapping, os);
        }
        else {
            return insertManyProvidingPk(conn, beanMapping, os);
        }
    }
    private <T> AVector<T> insertManyAutoGenerated(Connection conn, BeanMapping beanMapping, List<T> os) {
        return executeUnchecked(() -> {
            final BeanProperty pkProperty = beanMapping.pkProperty().orNull();

            final SqlBuilder builder = SqlSnippet.builder();
            boolean first = true;
            for (T o: os) {
                if (beanRegistry.getTableAwareMetaData(conn, o.getClass(), providedTableName) != beanMetaData) throw new IllegalArgumentException("multi-insert only for beans of the same type");
                appendInsertFragmentForElement(beanMetaData, builder, first, o, false);
                first = false;
            }

            if (pkProperty != null) {
                final List<?> pkValues = sqlEngine.insertSingleColPkInCol(pkProperty.columnName(), pkProperty.propType(), builder.build()).executeMulti(conn);
                if (pkValues.size() != os.size()) throw new IllegalStateException("inserting " + os.size() + " rows returned " + pkValues.size() + " - mismatch");

                final AVector.Builder<T> result = AVector.builder();
                for (int i=0; i<os.size(); i++) {
                    //noinspection unchecked
                    result.add((T) pkProperty.set(os.get(i), pkValues.get(i)));
                }
                return result.build();
            }
            else {
                sqlEngine.update(builder.build()).execute(conn);
                return AVector.from(os);
            }
        });
    }

    private <T> void appendInsertFragmentForElement (BeanMapping beanMapping, SqlBuilder builder, boolean first, T o, boolean includePkColumn) {
        if (first) {
            builder.append(insertStatement(beanMapping, o, includePkColumn));
        }
        else {
            builder
                    .append(",(")
                    .append(params(beanMetaData.writableBeanProperties(includePkColumn).map(p -> p.get(o))))
                    .append(")")
            ;
        }
    }

    private <T> AVector<T> insertManyProvidingPk(Connection conn, BeanMapping beanMapping, List<T> os) {
        return executeUnchecked(() -> {
            final AVector.Builder<T> result = AVector.builder();

            final SqlBuilder builder = SqlSnippet.builder();
            boolean first = true;
            for (Object withoutPk: os) {
                if (beanRegistry.getTableAwareMetaData(conn, withoutPk.getClass(), providedTablename) != beanMetaData) throw new IllegalArgumentException("multi-insert only for beans of the same type");
                final AOption<Object> optPk = beanMetaData.pkStrategy().newPrimaryKey(conn);
                final Object withPk;
                if (beanMetaData.pkProperty().isDefined()) {
                    withPk = optPk.fold(withoutPk, (res, el) -> beanMetaData.pkProperty().get().set(res, el));
                }
                else {
                    withPk = withoutPk;
                }
                appendInsertFragmentForElement(beanMetaData, builder, first, withPk, true);
                first=false;
            }

            sqlEngine.update(builder.build()).execute(conn);
            return result.build();
        });
    }

    public <T> T insert(T o) {
        return insert(engine().defaultConnection(), o);
    }
    private <T> T insert(Connection conn, T o) {
        final BeanMapping beanMapping = mappingRegistry.getBeanMapping(conn, o.getClass());
        if (beanMapping.pkStrategy().isAutoIncrement()) {
            return insertAutoGenerated(conn, o, beanMapping);
        }
        else {
            return insertProvidingPk(conn, o, beanMapping);
        }
    }
    private <T> T insertAutoGenerated(Connection conn, T o, BeanMapping beanMapping) {
        return executeUnchecked(() -> {
            final TableAwareBeanMetaData beanMetaData = beanRegistry.getTableAwareMetaData(conn, o.getClass(), providedTableName);
            final SqlSnippet insertStmt = insertStatement(beanMetaData, o, false);

            if (beanMetaData.pkProperty().isDefined()) {
                final BeanProperty pkProperty = beanMetaData.pkProperty().get();
                final Object pkValue = sqlEngine.insertSingleColPkInCol(pkProperty.columnName(), pkProperty.propType(), insertStmt).executeSingle(conn);
                //noinspection unchecked
                return (T) pkProperty.set(o, pkValue);
            }
            else {
                sqlEngine.update(insertStmt).execute(conn);
                return o;
            }
        });
    }
    private SqlSnippet insertStatement(BeanMapping beanMapping, Object bean, boolean withPk) {
        final SqlSnippet into = commaSeparated(
                beanMetaData
                        .writableBeanProperties(withPk)
                        .flatMap(p -> p.columnMetaData().map(m -> sql(m.colName())))
        );

        final SqlSnippet values = params(
                beanMetaData
                        .writableBeanProperties(withPk)
                        .flatMap(p -> p.columnMetaData().map(m -> p.get(bean)))
        );
        return concat(
                sql("INSERT INTO " + beanMetaData.tableName() + "("),
                into,
                sql(") VALUES ("),
                values,
                sql(")")
        );
    }
    private <T> T insertProvidingPk(Connection conn, Object beanWithoutPk, BeanMapping beanMapping) {
        return executeUnchecked(() -> {
            final TableAwareBeanMetaData beanMetaData = beanRegistry.getTableAwareMetaData(conn, beanWithoutPk.getClass(), providedTableName);

            final Object beanWithPk;
            if (beanMetaData.pkProperty().isDefined()) {
                final AOption<Object> optPk = beanMetaData.pkStrategy().newPrimaryKey(conn);
                beanWithPk = optPk.fold(beanWithoutPk, (res, el) -> beanMetaData.pkProperty().get().set(res, el));
            }
            else {
                beanWithPk = beanWithoutPk;
            }

            final SqlSnippet insertStmt = insertStatement(beanMetaData, beanWithPk, true);

            sqlEngine.update(insertStmt).execute(conn);
            //noinspection unchecked
            return (T) beanWithPk;
        });
    }

    public boolean update(Object bean) {
        return update(engine().defaultConnection(), bean);
    }
    private boolean update(Connection conn, Object bean) {
        return executeUnchecked(() -> {
            final BeanMapping beanMapping = mappingRegistry.getBeanMapping(conn, bean.getClass());
            if (beanMapping.pkProperty().isEmpty()) throw new IllegalArgumentException("update requires a bean to contain the table's primary key");

            final SqlSnippet updates = commaSeparated(
                    beanMapping.mappedPropertiesWithoutPk().keySet()
                            .map(p -> sql(p.columnName() + "=?", p.get(bean)))
            );

            final SqlSnippet stmt = concat(
                    sql("UPDATE " + beanMapping.tableName() + " SET"),
                    updates,
                    sql("WHERE " + beanMapping.pkProperty().get().columnName() + "=?", beanMapping.pkProperty().get().get(bean))
            );

            return sqlEngine.update(stmt).execute(conn) == 1;
        });
    }

    public boolean delete(Object bean) {
        return delete(engine().defaultConnection(), bean);
    }
    private boolean delete(Connection conn, Object bean) {
        final BeanMapping beanMapping = mappingRegistry.getBeanMapping(conn, bean.getClass());
        final BeanProperty pkProperty = beanMapping.pkProperty().orElseThrow(() -> new IllegalArgumentException("bean type " + bean.getClass() + " has no defined primary key"));

        return executeUnchecked(() ->
            sqlEngine.update("DELETE FROM " + beanMapping.tableName() + " WHERE " + pkProperty.columnName() + "=?", pkProperty.get(bean)).execute(conn) == 1
        );
    }
    public boolean delete(Class<?> beanType, Object pk) {
        return delete(engine().defaultConnection(), beanType, pk);
    }
    private boolean delete(Connection conn, Class<?> beanType, Object pk) {
        final BeanMapping beanMapping = mappingRegistry.getBeanMapping(conn, beanType);
        final BeanProperty pkProperty = beanMapping.pkProperty().orElseThrow(() -> new IllegalArgumentException("bean type " + beanType + " has no defined primary key"));

        return executeUnchecked(() ->
                sqlEngine.update("DELETE FROM " + beanMapping.tableName() + " WHERE " + pkProperty.columnName() + "=?", pk).execute(conn) == 1
        );
    }

    public boolean patch(Class<?> beanType, Object pk, Map<String,Object> newValues) {
        return patch(engine().defaultConnection(), beanType, pk, newValues);
    }
    private boolean patch(Connection conn, Class<?> beanType, Object pk, Map<String,Object> newValues) {
        final BeanMapping beanMapping = mappingRegistry.getBeanMapping(conn, beanType);
        final BeanProperty pkProperty = beanMapping.pkProperty().orElseThrow(() -> new IllegalArgumentException("bean type " + beanType + " has no defined primary key"));

        //TODO to-one / foreign keys

        final SqlBuilder builder = new SqlBuilder();
        boolean first = true;

        builder.append("UPDATE " + beanMapping.tableName() + " SET");

        for (String propName: newValues.keySet()) {
            final AOption<BeanProperty> optProp = beanMetaData.beanProperties().find(p -> p.name().equals(propName));
            if (optProp.isEmpty()) continue;

            final BeanProperty prop = optProp.get();
            if (prop.columnMetaData() == null) continue;

            if (first) {
                first = false;
            }
            else {
                builder.append(",");
            }
            builder.append(prop.columnName() + "=?", newValues.get(propName));
        }

        builder.append("WHERE " + pkProperty.columnName() + "=?", pk);

        return executeUnchecked(() ->
            sqlEngine.update(builder.build()).execute(conn) == 1
        );
    }
}
